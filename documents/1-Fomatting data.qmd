---
title: "Formatting GLT data"
author: "Aurore Ponchon"
format: html
editor: visual
---

# 1- Formatting data to constitute a full long dataset

Data are stored in .xls or .xlsx files. They consist of blocks of data encompassing groups from the same region. A first formatting of the tables is made directly within the excel files to ensure that each group name is the first line of a block. Region names are isolated before blocks so that they are automatically assigned to following blocks.

```{r}

#| echo: false
#| message: false
#| warning: false

library(here)
library(tidyverse)
library(readxl)
library(xlsx)
library(conflicted)
library(progressr)

conflict_prefer("mutate", "dplyr")

#Source files with specific functions
source(here::here("R","extract_functions.R"))
source(here::here("R","revalue_variables.R"))

#identify particular status in Grupo column

dispersers<-c("OUT","Out","out","OUT PT",
              "disp","Disp","DISP",
              "Grace-disp","Alex-disp","28/01/13", 
              "saiu","Expulsa")
solo<-c("Sozinha","Sozinho","sozinha","sozinho",
        "SOZINHA","soz.","SOZINHO","Soz.")
dead<-c("DEAD","died","Died","DIED")
names<-c("chiquinho","Georgia","Luisa","Antônia","Luana",
         "Camilo","André")

#list all files

files.recent<-list.files(here::here("data","RawData","Groups"),
                         pattern = "xls",recursive=T,
                         full.names = T)

files.old<-list.files(here::here("data","RawData","pdfData"),
                      pattern = "xls",recursive=T,
                      full.names = T)

#function to read each file separately
data.recent<- purrr::map_dfr(files.recent, extract_long_data,.progress=T)
data.old<- purrr::map_dfr(files.old, extract_long_data,.progress=T)

#bind everything
DATA<-rbind(data.old,data.recent)

#clean data with specific functions
data.clean<-DATA %>% 
  revalue_region() %>% 
#      revalue_birth() %>%    #issue with FA20 (2 birth dates!!)
  revalue_stage() %>% 
  revalue_sex() %>% 
  revalue_name() %>% 
  dplyr::arrange(GLT,DateObs)

#check unique group names and Regions
sort(unique(data.clean$Region))
sort(unique(data.clean$Group))

#write a file with group and region names
# data.clean %>%
#   dplyr::filter(GLT!="?" &
#                   GLT !="?-3" &
#                   GLT!="IN" &
#                   GLT!="FT" &
#                   GLT!="T0" &
#                   Group!="?") %>%
#   dplyr::select(DateObs,Region, Group, 
#                 GLT, Sexo,Idade,Disp,Death,Solo) %>%

# write.table(., file=here::here("Data","NewlyCreatedData","data_long.xslx"),
#            quote=F,row.names=F ,sep=";")

#filter individuals and produce final files

data.clean<-data.clean %>%
  dplyr::select(Year,DateObs,Region,Group,GLT,Tattoo,Sex,Idade, Disp, Death, Solo)

save(data.clean,file=here::here("Data",
                                "NewlyCreatedData",
                                "all_long.RData"))

#check group names 
# subseto<-DATA %>% 
#   filter(Group=="DN"|
#          Group=="Fugitivo"|
#          Group=="Fusão"|
#          Group=="GM"|
#            Group=="FQL"|
#            Group=="Jaguar"|
#            Group=="ML2"|
#            Group=="MR"|
#            Group=="NA") %>% 
#   select(-Grupo)
# 
# write_xlsx(subseto,
# path=here("Data","NewlyCreatedData","check_group_Valeria.xlsx"))
```

# 2- Checking duplicates and errors

Duplicates are checked in group and region names, as well as in individuals. Individual variables are also filled, to ensure that they are consistent among observations of the same individual (notably sex and date birth). After data corection, all objects should be empty!

```{r}
#| echo: false
#| message: false
#| warning: false

load(here::here("Data","NewlyCreatedData","all_long.RData"))

#filter individuals with non-identified names
bad<-c("?","T0","IN","?-1","?-2","?-3","FT","?-4","?-5","?-6", "FT")


#identify duplicates in individual names
#create an object with GLT duplicates
dup<-data.clean %>%
  dplyr::filter(!GLT %in% bad) %>% 
  dplyr::group_by(DateObs,GLT) %>%
  dplyr::summarise(n = dplyr::n(), .groups = "drop") %>%
  dplyr::filter(n > 1L) # & GLT!="?" & GLT!="T0" & GLT!="IN") %>% 

#get all observations of duplicates to reconstitute their individual histories

dups<-data.clean %>% 
  dplyr::filter(GLT %in% dup$GLT) %>% 
  dplyr::arrange(GLT, DateObs)

#1377 ok

#FT = weird!
# write_xlsx(dups,
#  path=here::here("Data","NewlyCreatedData","duplicated_individuals_all.xlsx"))

##checking duplicates in Sex
sexo<-data.clean %>%
  dplyr::group_by(GLT) %>%
  dplyr::summarise(Sexy = Sex,.groups="keep") %>% 
  distinct() %>% 
  dplyr::filter(n()>1)

#MP475 problematic (same birth and both M & F)

#1375 with 3 different dates!!
#AF22, AF23, AF24, AF25 born after observation and dispersed?!
#check FA40 (2018 & 2019)
#check FT (Part of duplicate names)
#JP23 duplicate
#check 1311, 1312, MP104, MP108, MP109, MP176, MP292, MP313, MP99, TM20, UR4

#check differences between GLT and tattoo
ind<-data.clean %>% 
  dplyr::filter(!is.na(Tattoo)) %>% 
  dplyr::filter(GLT!=Tattoo) %>% 
  dplyr::arrange(GLT,DateObs)

#check duplicates with groups and regions
group<-data.clean %>% 
  dplyr::filter(Disp==0 & Death==0 & Solo ==0) %>% 
  group_by(Group) %>% 
  dplyr::select(Group,Region) %>% 
  distinct() %>% 
  write.csv(., file=here::here("data","NewlyCreatedData","unique-group-region.csv",
                               sep=";",
                               quote=F,
                               row.names=F))

```

# 3- Formatting dataset to a wide format

The dataset for capture-recapture analyses includes individuals which have been clearly identified. Dispersed individuals and dead individuals are removed, as well as non identified infants.

Duplicate individual GLT and tattoos are renamed in the code, not in the files (see revalue_variables R file).

```{r}
load(here::here("Data","NewlyCreatedData","all_long.RData"))
bad<-c("?","T0","IN","?-1","?-2","?-3","FT","?-4","?-5","?-6")

sum.up<-data.clean %>% 
  group_by(Group,GLT) %>% 
  dplyr::arrange(DateObs)

## Produce a table with a wide format

dat<-data.clean %>% 
  dplyr::filter(Disp=="0" & Death=="0" & Solo=="0") %>% 
  dplyr::filter(!GLT %in% bad) %>% 
  dplyr::arrange(DateObs,Group) %>% 
  dplyr::select(DateObs,Region,Group, GLT, Sexo ) %>% 
  dplyr::distinct() %>% 
  pivot_wider(names_from=DateObs,
              names_prefix="Obs",
              values_from=Region) %>% 
  write.table(., file=here::here("Data","NewlyCreatedData","data_wide.xslx"),
              quote=F,row.names=F ,sep=";")

```

# 4- Checking continuity in observations

```{r}
library(viridis)
library(ggrepel)


fq<-data.clean %>%  
  dplyr::filter(!GLT %in% bad & Disp==0 & Death==0 & Solo==0) %>% 
  group_by(Group,DateObs) %>% 
  dplyr::count() %>% 
  group_by(Group) %>% 
  dplyr::count() %>% 
  dplyr::arrange(n) %>% 
  drop_na()

colorme<-rep(viridis(n=20,option="H"),time=11)

check<-data.clean %>% 
   dplyr::filter(!GLT %in% bad & Disp==0 & Death==0 & Solo==0) %>% 
  mutate(Group=as.factor(Group)) %>%
  mutate(Group=factor(Group,
                      levels=fq$Group)) %>% 
  ggplot(.,aes(x=DateObs,y=Group)) +
  geom_point(aes(colour=Group),shape=15,size=1.2,show.legend=F) +
  scale_colour_manual(values=colorme) +
    scale_y_discrete(guide = guide_axis(n.dodge = 2)) +
  # scale_x_date(limits=c(as.Date("2001-08-01",format="%F"),
  #                     as.Date("2022-11-01",format="%F")),
  #              date_breaks="2 year")+
  theme_bw() +
  labs(x="Date",y="Groups") +
 # coord_cartesian(clip = "off") +
  theme(legend.position = "none",
         axis.text.y = element_text(size=rel(1)))
 
tiff(here::here("outputs","Continuity_field_effort.tif"),
                width=6000,
                height=7000,
                res=600,
                compression="lzw")
print(check)
   dev.off()
```

<!--#  -->
