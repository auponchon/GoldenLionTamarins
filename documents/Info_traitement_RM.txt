Descriptif traitements données GLT
Romain Monassier

Données :
Données d'observation avec composition des groupes (/ semaines) = clean.raw.data.long. Identifiant du GLT = "GLT" ou "Tattoo".
En + : données d'indiv translocalisés (tranlocated_ind) ; d'évènements de dispersion (GLT_movement, 1989-2001) ; de capture (processamento_mld, 1989-2009). 
Format des données :
* 2001-2007 = PDF
* 2009-2022 = Excel



*** CORRECTION DU SEXE

I. Mise à jour des erreurs de typographie (m, M0, S)

II. Correction du sexe

Plusieurs sexes différents (n=43 GLT, soit 2,08% des GLT)
* Si deux valeurs (F/M et NA) : implémenter le sexe majoritaire dans les cellules NA (n=27 GLT)
* Si deux sexes (F + M) (n=16 GLT) : incertitudes sur les individus suivants
   GLT       F     M SexOK
 1 LC12      3    16 NA
 2 LC4       7     5 F
 3 O15       8     1 NA
 4 O16       1     1 NA
 5 PA3       1    17 NA
 6 PR15      1     3 NA
 7 PR8       2    15 NA
 8 PV4      14     1 NA
 9 RL11      3    15 NA
10 RL13      2    15 NA
11 RT1       1    19 M
12 SE3      17     2 NA
13 SF3       2     9 NA
14 SF4       1    10 NA
15 SK19      2    13 NA
16 ST3       1    19 NA


*** CORRECTION DE LA CATEGORIE D'AGE (IDADE)
Deux sources de données : fichier de Valéria ("BirthDates.xlsx") et données issues de GLT_movement. 

I. Données 1989-2022
Données sources : Utilisation des données de naissance (fichier de Valéria : BirthDates.xlsx) (naissances de 1989 à 2001)
EXCEL :
- Création d'un champ Birth_VR au format texte et à partir de la colonne BirthDate
- Quand le jour n'est pas connu : utilisation de 01/
- Identification des doublons dans le fichier de Valéria : existence de doublons dont les données sont identiques : OL7 OL8 RV6 PT3 OL10 MA3 RV7 + T4 mais qui n'a pas de date de naissance renseignée
R : CF le script
1) Import des fichiers
2) Suppression des GLT dupliqués
3) Filtrer les NAs

II. Données 2001-2022
Import des données (.Rdata)
Traitement dans R
Champ "Birth" de data.clean (Birth_mov)

III. Verification des erreurs dans les dates de naissance
1) Dates de naissances multiples (de la variable Birth_mov)
SOLUTION : Correction si erreurs évidentes (dates proches, ie < 180 jours)
* Deux dates différentes (n=120 individus) : correction pour les individus aux dates proches, incertitudes sur 52 individus = Mettre la date de naissance en NA
 1:  AS14
 2:  AT10
 3:  AT11
 4:  AX17
 5:   AX3
 6:   AX4
 7:   BE4
 8:   BQ1
 9:   BQ2
10:   BQ3
11:   CB5
12:  CM14
13:   DI1
14:   DI2
15:  FA12
16:  FA20
17:  JP23
18:    K3
19:   LB6
20:   LG2
21:   LG3
22:   LG4
23:   MK2
24:   MK7
25: MP119
26: MP176
27: MP177
28: MP272
29:  MP38
30:  MP39
31:  MP44
32:   O20
33:   OL1
34:  OL10
35:  OL18
36:    P8
37:    P9
38:   PR5
39:  RL24
40:   RP3
41:  RV13
42:  RV32
43:  RV33
44:    S6
45:   SF2
46:   SI5
47:  SP31
48:   SP5
49:  ST42
50:  TM19
51:  TR14
52:  TR18
* Trois dates différentes (n=7 GLT) : 1375, AF20, E25, KE10, KE4, RV6, SP23. Incertitude restante sur 1375 (NA)
1: 1375 NA
2: AF20
3:  E25
4: KE10
5:  KE4
6:  RV6
7: SP23
TOTAL : 53 individus avec NA

2) Incohérences entre les dates de naissance renseignées
* Si incohérence : garder la date de naissance issue de BirthDates (dates de naissance données par VR)
* PUIS : implémenter les dates de naissance NA pour les individus ayant une date de naissance connue

3) Différences entre la date de naissance et la date d'émigration de GLT_movement
* Comparaison entre la date de naissance renseignée et la date d'émigration supposée
* Incertitudes sur les individus (n=3) = Mettre la date de naissance en NA
A7 = NA
CA9 = NA
SK19 = NA

4) Individus observés avant la date de naissance renseignée :
* Calcul de la différence
* Mettre la date de naissance en NA si la différence est négative 

5) Individus dont la date de naissance (Birth_mov) = la date de première observation 
* Mettre la date de naissance en NA

6) Individus des mêmes groupes ayant la même date de naissance 
* Quand >= 3 individus : Mettre la date de naissance en NA
* Rajouter error type : Grp_sameBD (si n=3 ou n=4 : Grp_sameBD_?P)

7) Individus vus pour la première fois adultes et ayant une date de naissance 
* Mettre la date de naissance en NA

EXPORT des individus avec des dates de naissance erronnées/incertaines (n=969 GLT)



IV. Inférer le champ Idade sachant que :

On considère les catégories d'âge suivantes :
0-2 mois (0-60 jours) = Infant (IN)
3-10 mois (61-300 jours) = Juvenile (JU)
11-18 mois (301-540 jours) = Sub-adult (SA)
> 18 mois (> 540 jours) = Adult (AD)


Méthodes :

1) à partir de la date de naissance Birth_OK
2) à l'aide du champ Idade existant
* Remplir IdadeOK avec Idade là où NA
3) à l'aide du poids : AD > 550 g

? A l'aide d'une date de naissance inferrée depuis Idade ?
* On extrait les individus observés la première fois comme juvéniles
* On leur attribue une date de naissance fictive qui vaut la date d'observation - 5 mois

PUIS on remplit les cases vides à l'aide des catégories d'âge connues à certaines dates
* CAS 1 : individus adultes à une ou plusieurs dates
= On attribue adulte aux observations postérieures à la date où l'individu est adulte (qu'il s'agisse d'une case NA ou d'une case SA)
* CAS 2 : individus juvéniles à une ou plusieurs dates
= On attribue juvénile aux observations antérieures à la date où l'individu est juvénile (qu'il s'agisse d'une case NA ou d'une case SA)
* CAS 3 : individus juvéniles à une ou plusieurs dates
= On attribue adulte aux observations 16 mois postérieures (480 jours) à la date où l'individu est juvénile
* CAS 4 : individus sub-adultes à une ou plusieurs dates
= On attribue adulte aux observations 8 mois postérieures (240 jours) à la date où l'individu est sub-adulte



ERREURS :
1) Incohérences entre le stade et le poids (adultes < 550 g) et pour lesquels la date de naissance (VR) est inconnue
2) Incohérences entre les deux variables Idade
3) Incohérences chronologiques
EXPORT pour vérification manuelle

A L'ISSUE DE LA VERIFICATION :
* Restent des erreurs strictes liées au poids (sub-adulte > 550 g) mais avec une marge d'erreur suffisamment correcte pour ne pas être considérées comme des erreurs (poids entre 550 et 600 g)
* Demeurent des incertitudes sur (n=33) :
 1:  AF4
 2: AX22
 3: AX23
 4: AX24
 5:  BI1
 6: CM15
 7:  DI2
 8:  DN1
 9:  EL2
10:  FG1
11:  IR1
12:  IR2
13:  JO1
14: JP23
15:  LS1
16:  MB8
17:  MB9
18:  MD1
19:  MD2
20:  NC1
21:  O21
22: OL30
23:  PA5
24:  PR1
25: RL11
26: RT15
27: RV34
28:  SD1
29:  SD4
30:  SF9
31:  TM6
32:  TM7
33:  W21
SOLUTION : passer leur Idade en NA



V. Regarder les GLT qui n'ont ni Idade ni BirthDate


VI. ANALYSE STATISTIQUE

*** Données :
- Données d'observation des groupes de GLT
- Données mensuelles de précipitations de Worldclim (résolution 5 minutes ~85 km2) (Fick & Hijmans, 2017). CF : https://www.worldclim.org/data/monthlywth.html 

*** Préparation des données :
- GLT_Year = année (12 mois) d'une saison sèche à une autre (cf Dias et al. 2015). Mois de référence = mois où les groupes sont les plus stables (pas de naissance, pas d'immigration/émigration) (cf Dietz et al. 1994; Romano et al. 2018) = JUILLET
- Exemple : toute date strictement avant Juillet 1989 = 1988, et toute date dès Juillet et jusqu'à Juin de l'année suivante = 1989

*** Calcul des précipitations annuelles cumulées :
Données en entrée = précipitations mensuelles mondiales sur des cellules de 85km² (Worldclim)
Traitements : 
1) On crée un polygone qui correspond à l'étendue (bounding box) des UMMPs ; on applique un tampon rectangulaire de 7 km
2) On coupe les rasters avec ce polygone (mask) (utilisation de la fonction terra::crop)
3) On calcule la valeur de précipitations moyennes sur chaque raster
4) On calcule la précipitation annuelle cumulée sur une année GLT (et non civile)
Attention : les années GLT 1999 et 2021 sont calculées sur quelques mois seulement (car on n'a pas les données de 1999 et de 2022 pour les calculer)

*** Calcul du poids
Variable "weight" qui permet de prendre en compte l'inégalité de l'effort d'échantillonnage
w = nombre de groupes par fragment par an

*** Subset
- On ne garde que les données des fichiers d'observation
- On ne garde que les années de suivi entre 2000 et 2020
- On ne garde que les groupes suivis au moins 6 ans (à partir de l'année GLT) (ie 3 générations; d'après Strier & Mendes, 2009)
- On retire les groupes NA et les UMMPs NA


Statistiques élémentaires :
72 groupes, soit 1175 GLT connus répartis dans 10 MUs (UMMPs).
Période 2001-2020. 
Fréquence des visites : de 7 à 82 (mean +- SD = 30.7 +- 21.7). 
Fréquence moyenne de visite va de 0.35 visites à 5.7 visites/an (mean +- SD = 2.99 +- 1.37).

- Plot number of visits
- Plot mean annual visits

I. TAILLE ET CROISSANCE DES GROUPES
1) STATISTIQUES PAR GROUPE
CF script

- Plot taille du groupe dans le temps
- Plot taille du groupe selon les MUs
- Boxplot taille du groupe selon les saisons

2) STATISTIQUES DES FRAGMENTS
*** Fragment parameters
CF script

3) ANALYSE STATISTIQUE

* Matrice de corrélation :
                             Size      Shape  Perimetre cum_mean_cell_rainfall  GLT_Year1
Size                    1.0000000  0.9472631  0.9945902             -0.2831732  0.3737796
Shape                   0.9472631  1.0000000  0.9685681             -0.2345899  0.2399304
Perimetre               0.9945902  0.9685681  1.0000000             -0.2758024  0.3250574
cum_mean_cell_rainfall -0.2831732 -0.2345899 -0.2758024              1.0000000 -0.2937118
GLT_Year1               0.3737796  0.2399304  0.3250574             -0.2937118  1.0000000

A) GROUP SIZE (group level)
* Echantillon
10 UMMPs, 72 groupes, 170 fragments

* Normaliser les variables
Scaling by subtracting the mean so that it is centered at 0, and then dividing by the standard deviation
Standard scaling, also known as Standardization of values, we scale the data values such that the overall statistical summary of every variable has a mean value of zero and an unit variance value (https://www.digitalocean.com/community/tutorials/normalize-data-in-r).

* Distribution
Year_grp_size = negative binomial

* Modèle GLMM
Modèle Poisson sur-dispersé = passage en nbinom
A.1) Not-Nested Model : Group Size ~ Size + Rainfall + (1|Year) + (1|Group) + (1|UMMPs)
Erreur
A.2) Nested Model : Group Size ~ Size + Rainfall + (1|Year) + (1|UMMPs/Group)
Celui que l'on garde

NB : pas de puissance inférentielle suffisante pour tester l'interaction de l'année et de la taille du fragment (pas assez de données)

* Modèle final

 Family: nbinom2  ( log )
Formula:          Year_grp_size ~ Size_sc + Rainfall_sc + (1 | GLT_Year1) + (1 |  
    UMMPs/Group)
Data: GS_year
Weights: weight

     AIC      BIC   logLik deviance df.resid 
 21653.3  21684.3 -10819.7  21639.3      610 

Random effects:

Conditional model:
 Groups      Name        Variance  Std.Dev.
 GLT_Year1   (Intercept) 7.254e-03 0.085171
 Group:UMMPs (Intercept) 1.371e-01 0.370229
 UMMPs       (Intercept) 3.907e-06 0.001977
Number of obs: 617, groups:  GLT_Year1, 20; Group:UMMPs, 72; UMMPs, 10

Dispersion parameter for nbinom2 family (): 6.02e+07 

Conditional model:
            Estimate Std. Error z value Pr(>|z|)    
(Intercept) 2.070247   0.048708   42.50   <2e-16 ***
Size_sc     0.012542   0.013221    0.95    0.343    
Rainfall_sc 0.009242   0.020755    0.45    0.656    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

AA) GROUP SIZE (fragment level)
Taille du groupe moyenne annuelle sur le fragment ~ Taille du fragment + Rainfall + (1|UMMPs) + (1|Year)

* Echantillon
N = 170 fragments

* Distribution
Gamma

* Modèle final
Generalized linear mixed model fit by maximum likelihood (Laplace Approximation) ['glmerMod']
 Family: Gamma  ( inverse )
Formula: mean_annual_grp_size ~ Size_sc + (1 | GLT_Year1) + (1 | UMMPs)
   Data: Stat_frag_year
Weights: n_grp

     AIC      BIC   logLik deviance df.resid 
  2521.2   2536.9  -1255.6   2511.2      165 

Scaled residuals: 
    Min      1Q  Median      3Q     Max 
-2.6284 -0.6061 -0.1096  0.4176  3.4495 

Random effects:
 Groups    Name        Variance  Std.Dev.
 GLT_Year1 (Intercept) 0.0003801 0.01950 
 UMMPs     (Intercept) 0.0002977 0.01725 
 Residual              0.1710794 0.41362 
Number of obs: 170, groups:  GLT_Year1, 20; UMMPs, 10

Fixed effects:
             Estimate Std. Error t value Pr(>|z|)    
(Intercept)  0.133029   0.009843   13.52   <2e-16 ***
Size_sc     -0.003067   0.001503   -2.04   0.0413 *  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Correlation of Fixed Effects:
        (Intr)
Size_sc -0.022



B) GROWTH RATE (group level)

* Echantillon
72 groupes dans 10 UMMPs

* Normaliser les variables
Scaling by subtracting the mean so that it is centered at 0, and then dividing by the standard deviation
Standard scaling, also known as Standardization of values, we scale the data values such that the overall statistical summary of every variable has a mean value of zero and an unit variance value (https://www.digitalocean.com/community/tutorials/normalize-data-in-r).

* Distribution
Lognormale

* Modèles LMM avec fonction lmer (package lmerTest)
A.1) Not-Nested Model : Group Size ~ Size + Rainfall + (1|Year) + (1|Group) + (1|UMMPs)
A.2) Nested Model : Group Size ~ Size + Rainfall + (1|Year) + (1|UMMPs/Group)


* Modèle final =
Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite's method [
lmerModLmerTest]
Formula: logYGR ~ Size_sc + (1 | GLT_Year1) + (1 | UMMPs/Group)
   Data: GS_year2
Weights: weight

     AIC      BIC   logLik deviance df.resid 
   414.1    439.9   -201.0    402.1      539 

Scaled residuals: 
    Min      1Q  Median      3Q     Max 
-5.7947 -0.3347  0.0140  0.3768  4.2847 

Random effects:
 Groups      Name        Variance  Std.Dev.
 Group:UMMPs (Intercept) 0.000e+00 0.000000
 GLT_Year1   (Intercept) 3.383e-03 0.058159
 UMMPs       (Intercept) 7.802e-05 0.008833
 Residual                6.543e-01 0.808869
Number of obs: 545, groups:  Group:UMMPs, 72; GLT_Year1, 19; UMMPs, 10

Fixed effects:
              Estimate Std. Error         df t value Pr(>|t|)  
(Intercept)  0.0001454  0.0208448  3.5834300   0.007   0.9948  
Size_sc     -0.0436291  0.0148830  3.9612573  -2.931   0.0433 *
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Correlation of Fixed Effects:
        (Intr)
Size_sc -0.122
optimizer (nloptwrap) convergence code: 0 (OK)
boundary (singular) fit: see help('isSingular')

* Plot

C) GROUP DENSITY (fragment level)

* Echantillon : différent de l'analyse au niveau des groupes
Données d'observation de 2000 à 2021 ; 12 UMMPS et 232 fragments (définis comme des taches discrètes à l'année)
* Normaliser les variables
Scaling by subtracting the mean so that it is centered at 0, and then dividing by the standard deviation
Standard scaling, also known as Standardization of values, we scale the data values such that the overall statistical summary of every variable has a mean value of zero and an unit variance value (https://www.digitalocean.com/community/tutorials/normalize-data-in-r).

* Distribution
Lognormale

* Modèles LMM avec fonction lmer (package lmerTest)
Group Density ~ Size + Rainfall + (1|Year) + (1|UMMPs)

* Modèle final = 

Linear mixed model fit by maximum likelihood . t-tests use Satterthwaite's method [
lmerModLmerTest]
Formula: logGD ~ Size_sc + (1 | GLT_Year1) + (1 | UMMPs)
   Data: GD_year
Weights: n_grp

     AIC      BIC   logLik deviance df.resid 
   684.4    701.6   -337.2    674.4      227 

Scaled residuals: 
     Min       1Q   Median       3Q      Max 
-2.11915 -0.80322 -0.09321  0.53564  2.30752 

Random effects:
 Groups    Name        Variance Std.Dev.
 GLT_Year1 (Intercept) 0.000    0.000   
 UMMPs     (Intercept) 1.314    1.146   
 Residual              1.839    1.356   
Number of obs: 232, groups:  GLT_Year1, 20; UMMPs, 12

Fixed effects:
             Estimate Std. Error        df t value Pr(>|t|)    
(Intercept)  -5.13558    0.35285  10.63650  -14.55 2.32e-08 ***
Size_sc      -1.16942    0.05638 224.73602  -20.74  < 2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Correlation of Fixed Effects:
        (Intr)
Size_sc -0.028
optimizer (nloptwrap) convergence code: 0 (OK)
boundary (singular) fit: see help('isSingular')

* Plot