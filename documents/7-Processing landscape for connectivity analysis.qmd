---
title: "Landscape processing"
author: "Aurore Ponchon"
format: html
editor: visual
---

# 1-Import landscape layers

```{r}
#load packages
library(tidyverse)
library(here)
library(raster)
library(terra)
library(maptools)
library(fields)
library(sp)
library(rgdal)
library(landscapemetrics)
library(rgeos) 
library(gridExtra)
library(dplyr)
library(sf)
library(fasterize)

#load functions
source(here::here("R","create_raster.R"))
source(here::here("R","merge_ummp.R"))
source(here::here("R","fct_dilatation_erosion.R"))

id_paysage = "1990"

#projection for Brazil
proj<-"+proj=utm +zone=23 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs"

##############################################
## STEP 1 : LANDSCAPE PRE-PROCESSING ##
##############################################

##### 1- Import landscape layers

## Import layer of forest fragments for the study area extent
land<-sf::read_sf(here::here("data","RawData","Landscape",
                             "Shapefiles Landscape AMLD",
                             "SIG-EDUC Redescobrindo 2021 - Fragmentos de Vegetação.shp")) %>% 
      st_transform(.,crs = proj)


## Import roads and train lines
roads <- sf::read_sf(here::here("data","NewlyCreatedData","Landscape raster","SHP", 
                             "RoadsTrainUnion.shp")) %>% 
         st_set_crs(4326) %>% 
         st_transform(.,crs = proj) %>% 
         sf::st_crop(., y=land)


##Import landscapes with habitat codes (file as a raster sack compiling 30 years)
load(here::here("data","NewlyCreatedData","LandUseStack.RData"))
for_den_crop<-coverStack[[1]]

## Crop the study area and plot landscape
plot(for_den_crop, main = "Landscape")
#(land$geometry,add=T,border="grey")
plot(roads$geometry,add=T,col="red")


#conservation units (UMMPs)
ummp<-return_complete_ummp() #add vendaval and boa esperanza which are missing in shapefile
  
#remove accents in names
ummp$UMMPs<-plyr::revalue(ummp$UMMPs, c("Imbaú I" = "Imbau I",
                         "Imbaú II" = "Imbau II",
                         "Imbaú III" = "Imbau III",
                         "Poço das Antas" = "Poco das Antas",
                         "União I" = "Uniao I",
                         "União II" = "Uniao II"))


##### 2- Define raster features
resolution = res(for_den_crop)[1]
nb_cell_paysage = ncell(for_den_crop)
nb_lignes = nb_colonnes = sqrt(nb_cell_paysage)
cell_size = resolution * resolution
aire_tot = (nb_cell_paysage*resolution)^2


##### 3- Dilatation - Erosion


working_directory<-here()

file = for_den_crop

seuil = 100
dilatation_erosion_paysage = dilatation_erosion(file,seuil)
plot(dilatation_erosion_paysage, 
     type = "classes", 
     main = "Landscape dilatation - erosion",
     levels = legende,
     col = couleurs, 
     plg = list(cex = 0.7)
)







##### 5) Exclusion des routes avant définition des patchs
dilatation_erosion_paysage_sans_routes = mask(dilatation_erosion_paysage,roads, inverse=TRUE)
plot(dilatation_erosion_paysage_sans_routes, 
     type = "classes", 
     main = "ETAPE 5 : Paysage C après exclusion des routes",
     levels = c("Matrice", "Habitat","Routes"),
     col = c("#E2DEDE", "#0E9813","#FFFFFF"), 
     plg = list(cex = 0.7)
)




##### 6) Définition des patchs - region group

if (minmax(dilatation_erosion_paysage_sans_routes, compute=FALSE)[1]==1) { 
  #Si la valeur la plus petite est 1, on repasse en 0
  dilatation_erosion_paysage_sans_routes = dilatation_erosion_paysage_sans_routes-1
}
patchs = patches(dilatation_erosion_paysage_sans_routes,directions = 8, zeroAsNA=TRUE, allowGaps=FALSE)

# Affichage des patchs
plot(patchs,  
     main = "ETAPE 6 : Affichage des patchs du paysage C, toutes tailles confondues"
)
#freq_patchs = freq(patchs)
#View(freq_patchs)

#Récupérer la surface de chaque patch
taille_patchs <- zonal(cellSize(x=patchs, unit="m"), patchs, sum, as.raster=TRUE)
seuil_mini = 22500 #m²
seuil_maxi = 250000 #m² = 25ha

## Ne garder que les patchs dont la surface est inférieure à la surface minimum, pour le fichier de couts
patchs_inf_seuil_mini <- ifel(taille_patchs > seuil_mini, NA, patchs)
plot(patchs_inf_seuil_mini, 
     main = "ETAPE 6 : Affichage des patchs de taille inférieur à la valeur minimale"
)
#Vérification à l'aide du tableau de fréuence qu'on sélectionne les bons patchs OK: max(freq(patchs_inf_seuil_mini)[3])
#On remplace toutes les valeurs non nulles (=habitat) par 1
patchs_inf_seuil_mini[patchs_inf_seuil_mini > 0] <- 1



## Création d'un raster avec les patchs dont la surface est comprise entre min et max
patchs_superieur_seuil_mini <- ifel(taille_patchs < seuil_mini, NA, patchs)
patchs_taille_ok <- ifel(taille_patchs > seuil_maxi, NA, patchs_superieur_seuil_mini)

plot(patchs_taille_ok, 
     main = "ETAPE 6 : Affichage des patchs de taille correcte"
)

#Vérification à l'aide du tableau de fréuence qu'on sélectionne les bons patchs OK: 
#min(freq(patchs_taille_ok)[3])
#max(freq(patchs_taille_ok)[3])
id_max = minmax(patchs_taille_ok, compute=TRUE)[2]


## Création d'un raster avec les patchs dont la surface est supérieure au max --> tessalation
patchs_superieur_seuil_maxi <- ifel(taille_patchs < seuil_maxi, NA, patchs)

plot(patchs_superieur_seuil_maxi, 
     main = "ETAPE 6 : Affichage des patchs de taille supérieure à la valeur maximale"
)

#Vérification à l'aide du tableau de fréuence qu'on sélectionne les bons patchs OK: 
#min(freq(patchs_superieur_seuil_maxi)[3])


#Affichage de l'histogramme de la taille de chacun des patchs : 
taille_patches_m2 = freq(patchs)[3]*cell_size
hist(taille_patches_m2$count)


##### 7) Tessalation sur les patchs trop grands - tirage aléatoire

# Importation de la fonction
source("D:/STAGE MODELISATION/Carto/Automatisation_traitement_carto_R/Fonctions/fct_tessalation.R")

# Définition des paramètres
r=patchs_superieur_seuil_maxi
n = 1100

# Tirage des points aléatoires
points_aleatoire = tirage_pts_aleatoires(r,n)

#Tesselation
x = points_aleatoire[,1]
y = points_aleatoire[,2]
tesselation_aleatoire <- deldir(x, y)


#Définition des nouveaux patchs
new_patchs_aleatoire = decoupage_patchs(tesselation_aleatoire,id_max)

par(mfrow=c(1,1))
plot(new_patchs_aleatoire, 
     main = "ETAPE 7 : Découpage des grands patchs après tesselation aléatoire"
)

#Vérification que la taille des patchs correspond bien à ce qui était attendu
val = verif_decoupage(new_patchs_aleatoire)


##### 7bis) Tessalation sur les patchs trop grands - tirage regulier

# Définition des paramètres
r=patchs_superieur_seuil_maxi
n = 1800

# Tirage des points réguliers
par(mfrow=c(1,1))
points_regulier = tirage_pts_reguliers(r,n)

#Tesselation
x = points_regulier[,1]
y = points_regulier[,2]
tesselation_regulier <- deldir(x, y)

#Définition des nouveaux patchs
new_patchs_regulier = decoupage_patchs(tesselation_regulier,id_max)

plot(new_patchs_regulier, 
     main = "ETAPE 7 : Découpage des grands patchs après tesselation regulière"
)

#Vérification que la taille des patchs correspond bien à ce qui était attendu
val = verif_decoupage(new_patchs_regulier)



##### 8) Regroupement des patchs de taille OK et des patchs découpés précédement
mosaic_raster_aleatoire <- mosaic(new_patchs_aleatoire, patchs_taille_ok)
plot(mosaic_raster_aleatoire, 
     main = "ETAPE 8 : Patchs du paysage C susceptibles de constituer de l'habitat pour l'écureuil roux - tesselation aléatoire"
)


mosaic_raster_regulier <- mosaic(new_patchs_regulier, patchs_taille_ok)
plot(mosaic_raster_regulier, 
     main = "ETAPE 8 : Patchs du paysage C susceptibles de constituer de l'habitat pour l'écureuil roux - tesselation régulière"
)



```
