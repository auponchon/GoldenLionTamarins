---
title: "Landscape processing"
author: "Aurore Ponchon"
format: html
editor: visual
---

# 1-Import landscape layers

```{r}
#load packages
library(tidyverse)
library(here)
library(raster)
library(terra)
library(maptools)
library(fields)
library(landscapemetrics)
library(rgeos) 
library(gridExtra)
library(sf)
library(fasterize)

#load functions
source(here::here("R","create_raster.R"))
source(here::here("R","merge_ummp.R"))
source(here::here("R","fct_dilatation_erosion.R"))
source(here::here("R","fct_tessalation.R"))

id_paysage = "1990"

##############################################
## STEP 1 : LANDSCAPE PRE-PROCESSING ##
##############################################

##### 1- Import landscape layers

## Import layer of forest fragments for the study area extent
## Landscapes with habitat codes (file as a raster sack compiling 30 years)

load(here::here("data","NewlyCreatedData","LandUseStack.RData"))
for_den_crop<-coverStack[[1]] 
  

# land<-sf::read_sf(here::here("data","RawData","Landscape",
#                              "Shapefiles Landscape AMLD",
#                              "SIG-EDUC Redescobrindo 2021 - Fragmentos de Vegetação.shp")) %>% 
#       st_transform(.,crs = st_crs(for_den_crop))


## Import roads and train lines
roads <- sf::read_sf(here::here("data","NewlyCreatedData","Landscape raster","SHP", 
                             "RoadsTrainUnion.shp")) %>% 
         st_set_crs(4326) %>% 
         st_transform(.,crs = st_crs(for_den_crop)) %>% 
         sf::st_crop(., y=for_den_crop) %>% 
         sf::st_buffer(.,dist=100,
                       endCapStyle="ROUND")


## Crop the study area and plot landscape
plot(for_den_crop, main = "Landscape")
#(land$geometry,add=T,border="grey")
plot(roads$geometry,add=T,col="red")


#conservation units (UMMPs)
ummp<-return_complete_ummp() #add vendaval and boa esperanza which are missing in shapefile
  
#remove accents in names
ummp$UMMPs<-plyr::revalue(ummp$UMMPs, c("Imbaú I" = "Imbau I",
                         "Imbaú II" = "Imbau II",
                         "Imbaú III" = "Imbau III",
                         "Poço das Antas" = "Poco das Antas",
                         "União I" = "Uniao I",
                         "União II" = "Uniao II"))


##### 2- Define raster features
resolution = res(for_den_crop)[1]
nb_cell_paysage = ncell(for_den_crop)
nb_lignes = nb_colonnes = sqrt(nb_cell_paysage)
cell_size = resolution * resolution
aire_tot = (nb_cell_paysage*resolution)^2


##### 3- Dilatation - Erosion: 
#Transform the habitat into more homogeneous patches

working_directory<-here()

file = for_den_crop
hab<-as(for_den_crop, "SpatRaster")
hab[hab>1]<-0

legende <- c("Matrice", "Habitat")
couleurs <- c("#E2DEDE", "#0E9813")

seuil = 100
dilatation_erosion_paysage = dilatation_erosion(file,seuil)
par(mfrow=c(1,2))
plot(hab, 
     main = "Landscape dilatation - erosion",
     levels = legende,
     col = couleurs, 
     plg = list(cex = 0.7))

plot(dilatation_erosion_paysage, 
     type = "classes", 
     main = "Landscape dilatation - erosion",
     levels = legende,
     col = couleurs, 
     plg = list(cex = 0.7)
)


##### 4- Exclude roads before defning patches
dilatation_erosion_paysage_sans_routes = mask(dilatation_erosion_paysage,roads, inverse=TRUE)
plot(dilatation_erosion_paysage_sans_routes, 
     type = "classes", 
     main = "Landscape without roads",
     levels = c("Matrice", "Habitat","Routes"),
     col = c("#E2DEDE", "#0E9813","#FFFFFF"), 
     plg = list(cex = 0.7)
)


##### 5- Defining patches

if (minmax(dilatation_erosion_paysage_sans_routes, compute=FALSE)[1]==1) { 
  #SIf value <1, assign 0
  dilatation_erosion_paysage_sans_routes = 
    dilatation_erosion_paysage_sans_routes-1
}
patchs = patches(dilatation_erosion_paysage_sans_routes,
                 directions = 8, 
                 zeroAsNA=TRUE, 
                 allowGaps=FALSE)

#getting patch number
plot(patchs, main = "All patches")
# freq_patchs = freq(patchs)
# View(freq_patchs)

#get surface of each patch and define thresholds for patch size
taille_patchs <- zonal(cellSize(x=patchs, unit="m"), patchs, sum, as.raster=TRUE)
seuil_mini = 22500 #m²
seuil_maxi = 250000 #m² = 25ha

## Only keep patches which surface is lower than the minimal one. Keep object for the cost layer
patchs_inf_seuil_mini <- ifel(taille_patchs > seuil_mini, NA, patchs)
plot(patchs_inf_seuil_mini, main = "Too small patches")
#Check that we select the right patches
#max(freq(patchs_inf_seuil_mini)[3])

#replace non NA values (=habitat) by 1 
patchs_inf_seuil_mini[patchs_inf_seuil_mini > 0] <- 1


## Raster with patches which surface is between min and max threshold surfaces 
patchs_superieur_seuil_mini <- ifel(taille_patchs < seuil_mini, NA, patchs)
patchs_taille_ok <- ifel(taille_patchs > seuil_maxi, NA, patchs_superieur_seuil_mini)

plot(patchs_taille_ok, 
     main = "Single patches with right surfaces")

#Check selected patches by checking frequences
#min(freq(patchs_taille_ok)[3])
#max(freq(patchs_taille_ok)[3])
id_max = minmax(patchs_taille_ok, compute=TRUE)[2]


## Création d'un raster avec les patchs dont la surface est supérieure au max --> tessalation
patchs_superieur_seuil_maxi <- ifel(taille_patchs < seuil_maxi, NA, patchs)

plot(patchs_superieur_seuil_maxi, 
     main = "Too big patches")

#VCheck selected patches by checking frequences
#min(freq(patchs_superieur_seuil_maxi)[3])


#Histogramm of surface patches : 
taille_patches_m2 = freq(patchs)[3]*cell_size
hist(taille_patches_m2$count)


##### 6- Tessalation on biggest patches
r=patchs_superieur_seuil_maxi
n = 100000

# Tirage des points aléatoires
points_aleatoire = tirage_pts_aleatoires(r,n)

#Tesselation
x = points_aleatoire[,1]
y = points_aleatoire[,2]
tesselation_aleatoire <- deldir(x, y)


#Define new patches
new_patchs_aleatoire = decoupage_patchs(tesselation_aleatoire,id_max)

par(mfrow=c(1,1))
plot(new_patchs_aleatoire, main = "PATCHES AFTER RANDOM TESSELATION")

#Check that patch size is what is expected 
val = verif_decoupage(new_patchs_aleatoire)


##### 7) Tessalation on big patches wth regular samples

# Définition des paramètres
r=patchs_superieur_seuil_maxi
n = 180000

# Tirage des points réguliers
par(mfrow=c(1,1))
points_regulier = tirage_pts_reguliers(r,n)

#Tesselation
x = points_regulier[,1]
y = points_regulier[,2]
tesselation_regulier <- deldir(x, y)

#Définition des nouveaux patchs
new_patchs_regulier = decoupage_patchs(tesselation_regulier,id_max)

plot(new_patchs_regulier, 
     main = "PATCHES IN BIG AREAS AFTER TESSELATION")

#Vérification que la taille des patchs correspond bien à ce qui était attendu
val = verif_decoupage(new_patchs_regulier)



##### 8) Regroupement des patchs de taille OK et des patchs découpés précédement
par(mfrow=c(1,2))
mosaic_raster_aleatoire <- mosaic(new_patchs_aleatoire, patchs_taille_ok)
plot(mosaic_raster_aleatoire, 
     main = "Landscape with random tesselation")


mosaic_raster_regulier <- mosaic(new_patchs_regulier, patchs_taille_ok)
plot(mosaic_raster_regulier, 
     main = "Landscape with regular tesselation")

```

# 
